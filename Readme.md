# TinyFiber

⾯试中，⾯试官经常会问这样的问题，“你知道线程和进程区别吗？”然后会紧接着追问“你了解协程吗？协程和进程、线程⼜有什么区别？”

我们通过基础知识的学习和如 WebServer 此类项⽬，已经对进程和线程有了⽐较深的理解，但对协程相关知识却知之甚少。

协程作为⼀种强⼤的并发编程技术，可以在需要处理⼤量I/O操作或者并发任务的情况下提⾼程序的性能和可维护性。在许多场景应⽤⼴泛，通过实现协程库的项目，来提高自己 C++ 编程能⼒、对操作系统和计算机网络有更深的理解。

## 前置知识

- 编程语言：C++11 的常见特性，如智能指针、lambda 表达式、std::function、std::thread 等
- 操作系统和 Linux 常见系统调用
- 计算机网络基础知识：Linux 下的⽹络编程，常⻅⽹络编程 API、⽹络 IO，IO 多路复⽤、⾼性能⽹络模式：Reactor 和 Proactor 
- 

## 协程基础知识

通用的说法是**协程**是一种“轻量级线程”、“用户态线程”。

每个协程在创建时都会指定一个入口函数，这点可以类比线程。协程的本质就是*函数和函数运行状态的组合*。

协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（yield），暂时让出 CPU 执行权，在后面恰当的时机重新恢复运行（resume），在这段时间其他的协程可以获得 CPU 并运行。

协程能够 yield、resume 的关键是存储了函数在 yield 时间点的执行状态，即**协程上下文**。

协程上下文包含了函数在当前执行状态下的全部 CPU 寄存器的值，记录了函数栈帧、代码的执行位置等信息，如果把这些寄存器的值重新设置给 CPU，就相当于重新恢复了函数的运行。

单线程环境下，协程的 yield 和 resume 一定是同步进行的，一个协程的 yield 一定对应另一个协程的 resume，因为线程不可能没有执行主体，而且协程的 yield 和 resume 是完全由应用程序来控制的。（线程创建后，其运行和调度由操作系统自动完成）

### 对称协程和非对称协程

-  对称协程，协程可以不受限制地将控制权交给其他协程。任何一个协程都是相互独立且平等的，调度权可以在任意协程之间转移。
-  非对称协程，协程之间存在类似堆栈的调用方-被调用关系，协程出让调度权的目标只能是它的调用者。

### 有栈协程与无栈协程

- 有栈协程
  - 独立栈
  - 共享栈
- 无栈协程


### 协程的优缺点

- 优点
  - 提高资源利用率，提高程序并发性能
  - 简化异步编程逻辑
- 缺点
  - 无法利用多核资源

## 协程的实现



## TODO

- [ ] 协程类的实现
  - [ ] test1
- [ ] 协程调度
- [ ] 协程 + IO
- [ ] 定时器
- [ ] hook 

## 参考资料

- 游双《Linux⾼性能服务器编程》
- 陈硕《Linux多线程服务端编程：使⽤muduo C++⽹络库》
- 开源项目 https://github.com/sylar-yin/sylar
- 教程 https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060957
